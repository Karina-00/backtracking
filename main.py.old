from sys import argv
from copy import deepcopy

from tabulate import tabulate
from click import style

from ggen import Generator
# from repr import *


def create_graph():
    """Tworzy graf"""
    v = int(input("Podaj ilosc wierzcholkow grafu:"))
    print("Podaj kolejne wiersze macierzy sasiedztwa:")
    matrix = []
    for i in range(v):
        line = list(map(int, input(f"{i+1} linia:").split()))
        matrix.append(line)
    return matrix


def tabela_krawedzi(matrix):
    print(style("\nTabela krawedzi", fg='blue'))
    n = len(matrix)
    table = []
    for i in range(n):
        for j in range(n):
            if matrix[i][j] == 1:
                table.append([i + 1, j + 1])
    print(tabulate(table, headers=["out", "in"], tablefmt='orgtbl'))
    return table

# list


def create_in_degree_list(list, n):
    in_degree = []
    flatten = [val for sublist in list for val in sublist[1]]
    for i in range(n):
        degree = flatten.count(i + 1)
        in_degree.append([i + 1, degree])
    return in_degree


def next_by_list(list, i):
    return list[i][1]


def sort_bfs_by_list(list, n):
    in_degree = create_in_degree_list(list, n)
    print(style("\nSortowanie BFS >> Lista nastepnikow", fg='blue'))
    return sortowanieBFS(in_degree, next_by_list, list)
# list end ---


# table
def create_in_degree_table(table, n):
    in_degree = []
    flatten = [table[k][1] for k in range(len(table))]
    for i in range(n):
        degree = flatten.count(i + 1)
        in_degree.append([i + 1, degree])
    return in_degree


def next_by_table(table, i):
    successors = []
    for j in range(len(table)):
        if table[j][0] == i + 1:
            successors.append(table[j][1])
    return successors


def sort_bfs_by_table(table, n):
    print(style("\nSortowanie BFS >> Tabela krawedzi", fg='blue'))
    in_degree = create_in_degree_table(table, n)
    return sortowanieBFS(in_degree, next_by_table, table)
# table end ---


# main bfs_sort
def lower_degree(successors, in_degree):
    for i in range(len(in_degree)):
        if in_degree[i][0] in successors:
            in_degree[i][1] -= 1
    return in_degree


def sortowanieBFS(in_degree, find_next, data):
    result = []
    while max([in_degree[k][1] for k in range(len(in_degree))]) > -1:
        for i in range(len(in_degree)):
            if in_degree[i][1] == 0:
                in_degree[i][1] = -1
                result.append(i + 1)
                successors = find_next(data, i)
                in_degree = lower_degree(successors, in_degree)
    return " -> ".join(list(map(str, result)))


# sortowanie DFS -------------
def dfs_sort_matrix(matrix):
    print(style("\nSortowanie DFS >> Macierz sasiedztwa", fg='blue'))
    return sortowanieDFS(next_by_matrix, matrix, len(matrix))


def dfs_sort_list(list, n):
    print(style("\nSortowanie DFS >> Lista nastepnikow", fg='blue'))
    return sortowanieDFS(next_by_list, list, n)


def dfs_sort_table(table, n):
    print(style("\nSortowanie DFS >> Tabela krawedzi", fg='blue'))
    return sortowanieDFS(next_by_table, table, n)


def dfs_sort(v, szare, result, find_next, data):
    if v in result:
        return result, szare
    szare.append(v)
    successors = find_next(data, v - 1)
    for el in successors:
        result, szare = dfs_sort(el, szare, result, find_next, data)
        if el not in result:
            result.append(el)
    return result, szare


def sortowanieDFS(find_next, data, nr_of_vertexes):
    result = []
    szare = []
    n = nr_of_vertexes
    for v in range(1, n + 1):
        if v not in result:
            result, szare = dfs_sort(v, szare, result, find_next, data)
            result.append(v)
    return " -> ".join(list(map(str, result[::-1])))
